## 인터페이스의 역할

자바에서 인터페이스는 객체의 사용 방법을 정의한 타입이다. 인터페이스는 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 한다. 인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 한다. 개발 코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드를 호출시킨다. 그렇기에 개발 코드는 객체의 내부 구조를 알 필요가 없고 인터페이스 메소드만 알고있으면된다.

### 인터페이스를 중간에 두는 이유?

- 개발 코드를 수정하지않고 사용하는 객체를 변경하기위해서
  - 인터페이스는 하나의 객체가 아니라 여러 객체들과 사용이 가능하므로 어떤 객체를 사용하는가에 따라 실행 내용과 리턴값이 다를수있다. 따라서 개발 코드 측면에서는 코드 변경없이 실행 내용과 리턴값을 다양화할 수 있다는 장점이있다.

### 인터페이스 선언

인터페이스 선언은 class 키워드 대신 interface 키워드를 사용한다

```java
public interface 인터페이스명{}
```

- 클래스는 필드, 생성자, 메소드를 구성멤버로 가지는데, 인터페이스는 **상수와 메소드만**을 구성 멤버로 가진다.
- 인터페이스는 객체로 생성할 수 없기 떄문에 생성자를 가질수 없다.
- 자바 8 부터 디폴트 메소드와 정적 메소드도 선언이 가능하다.

```java
interface 인터페이스명{
	//상수
	타입 상수명 = 값;

	//추상메소드
	타입 메소드명(매개변수,);

	//디폴트 메소드
	default 타입 메소드명(매개변수,){}

	//정적 메소드
	static 타입 메소드명(매개변수){}

}
```

### 상수필드

인터페이스는 객체 사용 설명서이므로 런타임 시 데이터를 저장할 수 있는 필드는 선언할 수 없다.

그러나 상수 필드는 선언 가능! ← 고정값이기에 런타임 시에 데이터를 바꿀 수 없다.

단 상수를 선언할 때에는 반드시 초기값을 대입해야함

### 추상 메소드

추상 메소드는 객체가 가지고 있는 메소드를 설명한 것으로 호출할 때 어떤 매개값이 필요하고 , 리턴 타입이 무엇인지만 알려준다. 실제 실행부는 객체가 가지고있다.

### 디폴트 메소드

디폴트 메소드는 인터페이스에 선언되지만 사실은 객체가 가지고 있는 인스턴스 메소드라고 생각해야한다.

### 정적 메소드

디폴트 메소드와는 달리 객체가 없어도 인터페이스만으로 호출이 가능하다.

### 인터페이스 구현

개발코드가 인터페이스 메소드를 호출하면 인터페이스는 객체의 메소드를 호출한다. 객체는 인터페이스에서 정의된 추상 메소드와 동일한 메소드 이름, 매개 타입, 리턴 타입을 가진 실체 메소드를 가지고 있어야한다. 이러한 객체를 **인터페이스의 구현 객체**라고 하고 구현 객체를 생성하는 클래스를 **구현 클래스**라고한다.

### 구현 클래스

인터페이스 타입으로 사용할 수 있음을 알려주기 위해 클래스 선언부에 implements 키워드를 추가하고 인터페이스명을 명시해야한다.

```java
public class 구현클래스명 implents 인터페이스명{
	//인터페이스에 선언된 추상 메소드의 실체 메소드 선언
}
```

인터페이스에 선언된 추상 메소드의 실체 메소드를 선언해야함.

```java
public class Tv implements RemoteControl{

private int volum;

//turnOn() 추상메소드 실체 메소드
public void turnOn(){
 System.out.println("TV켬");
}
public void turnOff(){
 System.out.println("TV끔");
}

//setVolume() 추상 메소드의 실체 메소드
public void setVolume(int volume) {
	if(volume>RemoteControl.MAX_VOLUME){
		this.volume = RemoteControl.MAX_VOLUME;
	} else if(volume<RemoteConrol.MIX_VOLUME){
		this.volume = RemoteControl.MIN_VOLUME;
		} else {
		this.volume = volume;
		}
		System.out.println("현재 tv 볼륨"+ volume)
}
```

### 주의

- 인터페이스의 모든 메소드는 기본적으로 public 접근 제한을 갖기 때문에 public보다 낮은 접근 제한으로 작성할수 없음
- 만약 인터페이스에 추상 메소드에 대응하는 실체 메소드를 구현 클래스가 작성하지않으면 구현 클래스는 자동적으로 추상 클래스가 된다. 그렇기에 클래스 선언부에 abstract 키워드를 추가해야한다.

### 인터페이스 상속

인터페이스도 다른 인터페이스를 상속할수있다.

- 클래스와 달리 다중 상속 가능
- extends 키워드 뒤에 상속할 인터페이스 나열할수있다.

```java
public interface 하위인터페이스 extends 상위인터페이스1, 상위인터페이스2{}

```

하위 인터페이스를 구현하는 클래스는 하위인터페이스의 메소드뿐만이 아닌 상위 인터페이스의 모든 추상 메소드에 대한 실체 메소드를 가지고있어야함.

그렇기에 구현 클래스로부터 객체를 생성하고 하위 및 상위 인터페이스 타입으로 변환 가능

```java
하위 인터페이스 변수 = new 구현클래스();
상위 인터페이스1 변수 = new 구현클래스();
상위 인터페이스2 변수 = new 구현클래스();
```
