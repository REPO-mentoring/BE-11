# 상속

상속은 부모가 자식에게 물려주는 행위를 말한다.

자식은 상속을 통해서 부모가 물려준것에 자유롭게 사용이 사능하다.

객체 지향 프로그램에서도 부모 클래스의 멤버를 자식 클래스에게 물려줄수있다.

상속은 이미 잘 개발된 클래스를 재사용해 코드의 불필요한 중복을 줄여준다.

**단 부모클래스에서 private로 접근 제한을 갖는 필드와 메소드는 제외됨**.

상속을 이용하면 클래스 수정을 최소화할수있고. 부모 클래스의 수정으로 모든 자식 클래스가

수정되어 유지보수에 좋다!

예: 클래스 B,C가 클래스 A를 상속할경우 A의 필드와 메소드를 수정하면 물려받은 B,C도 수정된다.

주의: 여러개의 부모 클래스는 상속할수없음 그러므로 extends뒤에는 단하나의 부모 클래스만 와야한다.

### 부모 생성자 호출

모든 객체는 클래스의 생성자를 호출해야만 생성된다.

부모 객체도 예외는 아니다. 그렇다면 부모 객체를 생성하기위해 부모 생성자를 어디서 호출한 것일까?

부모 생성자는 자식 생성자의 맨 첫줄에서 호출된다.

예 : DmbCellPhone 의 생성자가 명시적으로 선언되지 않았다면 컴파일러는 다음과 같은 기본 생성자를 생성해낸다.

```java
public DmbCellPhone(){
	super();
}
```

첫 줄에 super(); 가 추가된 것을 볼 수 있다 . super()는 부모의 기본 생성자를 호출한다. 즉 CellPhone 클래스의 다음 생성자를 호출한다

```java
public CellPhone(){

}
```

CellPhone 생성자가 선언되지 않았지만 컴파일러에 의해 기본 생성자가 만들어지므로 문제없이 실행된다.

만약 직접 자식 생성자를 선언하고 명시적으로 부모 생성자를 호출하고싶으면 다음과같이 작성한다

```java
자식클래스(매개 변수 선언 , ) {
	super(매개값, );
}
```

- super(매개값,)는 매개값의 타입과 일치하는 부모 생성자를 호출한다. 만약 매개값의 타입과 일치하는 부모 생성자가 없을경우 컴파일 오류가 발생한다.
- super(매개값)이 생략되면 컴파일러에 의해 super()가 자동으로 추가되기에 부모의 기본 생성자가 존재해야함
- 부모 클래스에 기본생성자가 없고 매개변수가 있는 생성자만 있다면 자식 생성자에서 반드시 부모 생성자 호출을 위해 super(매개값)을 명시적으로 호출해야함.
- super(매개값)는 반드시 자식생성자 첫 줄에 위치하기!

### 메소드 재정의

부모 클래스의 모든 메소드가 자식 클래스에게 맞게 설계되어 있다면 가장 이상적인 상속이지만.

어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을수도있음

이 경우 상속된 일부 메소드는 자식 클래스에서 다시 수정해서 사용해야한다.

자바는 이런 행위를 위해 Overriding을 재공한다.

### 메소드 재정의 @Override

메소드 오버라이딩은 상속된 메소드의 내용이 자식 클래스 맞지않을경우 자식 클래스에서 동일한 메소드를 재정의하는것을 말합니다. 메소드가 오버라이딩되었다면 부모 객체의 메소드는 숨겨지기 때문에,

자식 객체에서 메소드를 호출하면 오버라이딩된 자식 메소드가 호출됩니다.

메소드 오버라이딩 규칙

- 부모의 메소드와 동일한 시그니처를 가져야한다.
- 접근 제한을 더 강하게 오버라이딩할순없다.
- 새로운 예외를 throws 할수없다.

접근 제한을 더 강하게 오버라이딩을 할수없다는것은 부모 메소드가 public 접근 제한을 가지고있을 경우

오버라이딩하는 자식 메소드는 default나 private접근 제한을 수정할수없다는것을 말한다.

허나 반대는 가능하다. 부모 메소드가 default접근 제한을 가지면 재정의되는 자식메소드는 default 또는 public 접근 제한을 가질 수 있다.

### 부모 메소드 호출(super)

자식 클래스에서 부모 클래스의 메소드를 오버라이딩하게 되면 , 부모 클래스의 메소드는 숨겨지,고 오버라이딩된 자식 메소드만 사용된다. 그러나 자식 클래스 내부에서 오버라이딩된 부모 클래스의 메소드를 호출해야하면 명시적으로 super키워드를 붙여서 부모 메소드를 호출할수 있다. super는 부모 객체를 참조하고 있기 때문에 부모 메소드에 직접 접근할수있다.

### final 클래스와 final 메소드

final 키워드는 클래스 ,필드, 메소드 선언 시에 사용할 수 있다. final 키워드는 해당 선언이 최종 상태이고, 결코 수정될수 없음을 뜻함. final 키워드가 클래스, 필드, 메소드 선언에 사용될 경우 해석이 조금씩 달라진다.

### 상속할수 없는 final 클래스

클래스를 선언할때 final 키워드를 class 앞에 붙이게 되면 이 클래스는 최종적인 클래스이므로 속할 수 없는 클래스가 된다. 즉 final 클래스는 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없다는 것이다.

### 오버라이딩할 수 없는 final 메소드

메소드를 선언할 때 final 키워드를 붙이게 되면 이 메소드는 최종적인 메소드이므로 오버라이딩을 할수 없는 메소드가 된다.

즉 부모 클래스를 상속해서 자식 클래스를 선언할 때 부모 클래스에 선언된 final 메소드는 자식 클래스에서 재정의 할 수 없다는 것이다.

### protected 접근제한자

protected는 public 과 default 접근 제한의 중간쯤에 해당한다. 같은 패키지에서는 default와 같이 접근 제한이 없지만 다른 패키지에서는 자식 클래스만 접근을 허용한다.

protected는 필드와 생성자, 메소드 선언에 사용될수 있다.

### 타입 변환과 다형성

다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 코드 측면에서 보면 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다. 다형성을 위해 자바는 부모 클래스의 타입 변환을 허용한다. 즉 부모 타입에 모든 자식 객체가 대입될수있다. 이것을 이용하면 객체는 부품화가 가능하다.

### 자동 타입 변환

자동 타입 변환은 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것을 말한다. 자동 타입 변환은 다음과 같은 조건에서 일어난다

```java
부모클래스 변수 = 자식클래스타입;
```

자동 타입 변환의 개념은 자식은 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다는것이다.

### 매개변수의 다형성

매개값을 다양화하기위해 매개변수에 자식 타입 객체를 지정할수도있다.

예를들어 다음과 같이 Driver라는 클래스가 있다. Driver클래스에는 drive() 메소드가 정의 되어 있는데 Vehicle타입의 매개 변수가 선언되어있다.

```java
class Driver{
	void drive(Vehicle vehicle){
		vehicle.run();
}
```

drive 메소드를 정상적으로 호출한다면 다음과 같다

```java
Drive drive = new Driver();
Vehicle vehicle = new vehicle();
drive.drive(vehicle);
```

만약 Vehicle의 자식 클래스인 Bus객체를 drive() 메소드의 매개값으로 넘겨준다면

drive()메소드는 Vehicle 타입을 매개변수로 선언했지만. Vehicle을 상속받는 Bus 객체가 매개값으로 사용되면 자동타입 변환이 발생한다.

매개변수의 타입이 클래스일 경우, 해당 클래스의 객체뿐만 아니라 그 자식 클래스의 객체도 매개값으로 사용할 수 있다. 이때 어떤 자식 객체가 전달되느냐에 따라 메소드의 실행 결과는 달라질 수 있다. 특히 자식 객체가 부모 클래스의 메소드를 재정의(오버라이딩)한 경우, 메소드 내부에서 오버라이딩된 메소드가 호출되어 실행 결과가 더욱 다양해진다.

### 강제 타입 변환

강제 타입 변환은 부모 타입을 자식 타입으로 변환한것을 말한다.

그렇다고 모든 부모 타입을 자식 클래스 타입으로 강제 변환할수 있는것은 아니다.

**자식 타입이 부모 타입으로 자동 변환후 다시 자식 타입으로 변환할때 강제 타입 변환을 사용할 수 있다.**

```java
자식 클래스 변수 = (자식클래스) 부모클래스타입;
```

자식 타입이 부모 타입으로 자동 변환하면 , 부모 타입에 선언된 필드와 메소드만 사용가능하다는 제약 사항이 따른다. 만약 자식 타입에 선언된 필드와 메소드를 꼭 사용해야한다면 강제 타입 변환을 해서 다시 자식 타입으로 변환한 다음 자식 타입의 필드와 메소드를 사용하면된다.

### 추상클래스

객체를 직접 생성할수있는 클래스를 실체 클래스라고 하는 반면

이 클래스들의 공통적인 **특성을 추출해서 선언한 클래스를 추상 클래스**라고 한다. 추상 클래스와 실체 클래스는 상속의 관계를 가지고있다. 추상 클래스가 부모이고 실체 클래스가 자식으로 구현되어 실체 클래스는 추상 클래스의 모든 특성을 물려받고, 추가적인 특성을 가질 수 있다. 여기서 특성이란 필드와 메소드들을 말한다.

예: Bird.class, Insect.class, Fish.class 등의 실체 클래스에서 공통되는 필드와 메소드를 따로 선언한 Animal.class 클래스를 만들 수 있는데 이것이 바로 추상 클래스이다.

추상 클래스는 실체클래스의 공통되는 필드와 메소드를 추출하여 만들었기에 객체를 직접 생성해서 사용할수는없다. 다시 말해서 추상클래스는 new연산자를 통해 인스턴스를 생성하지 못한다.

```java
Animal animal = new Animal(); (X)
```

추상클래스는 새로운 실체 클래스를 만들기위해 부모 클래스로만 사용됨으로. 코드로 설명하자면 extends 뒤에만 올수있다.

예 : Ant클래스를 만들기위한 Animal 클래스는 다음과 같이 사용할수있다

```java
class Ant extends Animal{
}
```

### 추상 클래스의 용도

실체 클래스들의 공통적인 특성(필드,메소드)을 뽑아내어 추상 클래스를 만드는 이유

- 첫번째 실체 클래스들의 공통된 필드와 메소드의 이름을 통일할 목적
  1. 실체 클래스를 설계하는 사람이 여러 사람일 경우 실체 클래스마다 필드와 메소드가 제각기 다른 이름을 가질수 있다. 예를들면 소유자의 이름을 저장하는 필드를 Telephone에서는 owner라고 하고, smartPhone에서는 user라고 할수있다. 그리고 전원을 켜다 라는 메소드를 Telephone 에서는 turnOn() 으로 설계하고 SmartPhone에서는 powerOn()이라고 설계할수 있다. 동일한 데이터와 기능임에도 불구하고 이름이 다르다 보니, 객체마다 사용 방법이 달라진다. 이것보다는 Phone이라는 추상 클래스에 소유자인 owner 필드와 turnOn()메소드를 선언하고, Telephone과 SmartPhone은 Phone을 상속함으로써 필드와 메소드를 통합함
- 두번째 실체 클래스를 작성할 때 시간 절약
  공통적인 필드와 메소드는 추상클래스 Phone에 모두 선언해 두고, 실체 클래스마다 다른점만 실체 클래스에 선언하게 되면 실체 클래스를 작성하는데 시간을 절약할수있음

### 추상클래스 선언

추상 클래스를 선언할때에는 클래스 선언에 abstract 키워드를 붙여야한다. abstract를 붙이게 되면 new 연산자를 이용해서 객체를 만들지 못하고 상속을 통해 자식 클래스만 만들 수 있다.

추상 클래스도 일반 클래스와 마찬가지로 필드,생성자,메소드선언을 할 수 있다. new 연산자로 직접 생성자를 호출할 수는 없지만 자식 객체가 생성될때 super()를 호출해서 추상 클래스 객체를 생성하므로 추성클래스도 생성자가 반드시 있어야한다.

### 추상메소드와 오버라이딩

추상 메소드는 추상 클래스에서만 선언할 수 있다. 메소드의 선언부만 있고 메소드 실행 내용인 중괄호 {}가 없는 메소드를 말한다. 추상 클래스를 설계할때 하위 클래스가 반드시 실행 내용을 채우도록 강요하고싶은 메소드가 있을 경우

해당 메소드를 추상 메소드로 선언하면된다. 자식 클래스는 반드시 추상 메소드를 재정의(Override) 해서 실행 내용을 작성해야하는데 그렇지 않으면 에러가 발생함

### 예시

```java
public abstract class Animal{
	public abstract void sound();
}
```

어떤 소리를 내는지는 결정 할 수없지만 동물은 소리를 낸다는 공통적인 특징이 있으므로 sound()메소드를 추상 메소드로 선언하였다.

```java
public abstract class Animal{
	public string kind;

	public void breathe(){
	System.out.println("숨을쉽니다");
	}
	public abstract void sound();
}
```

```java
public class Cat extends Animal{
	public Cat(){
		this.kind = "포유류";
	}

	@Override //추상 메서드 재정의
	public void sound(){
		System.out.println("야옹")
	}
}
```
