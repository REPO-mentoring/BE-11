### 예외와 예외 클래스

자바에서는 에러 이외에 예외라고 부르는 오류가 있다. 예외란 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류를 말한다. 예외가 발생되면 프로그램은 곧바로 종료된다는 점에서는 에러가 동일하다. 그러나 예외 처리를 통해 프로그램을 종료하지않고 정상 실행 상태가 유지되도록할 수 있다.

예외는 두가 종류가있음

- 예외(Exception)
- 실행 예외(Runtime Exception)

jvm은 프로그램을 실행하는 도중에 예외가 발생하면 해당 예외 클래스로 객체를 생성한다.

모든 예외 클래스들은 다음과 같이 java.lang.Exception 클래스를 상속받는다.

일반 예외와 실행 예외 클래스를 구별하는 방법은 일반 예외는 Exception을 상속 받지만 RuntimeException을 상속받지 않는 클래스들이고, 실행 예외는 다음과 같이 RuntimeException을 상속 받는 클래스들이다. RuntimeException 역시 Exception을 상속받지만 , JVM은 RuntimeException 을 상속했는지 여부를 보고 실행 예외를 판단한다.

### 실행 예외

실행 예외는 자바 컴파일러가 체크를 하지 않아 개발자의 경험에 의해서 예외처리코드를 삽입해야한다.

만약 개발자가 실행 예외에 대해 예외 처리 코드를 넣지 않았을 경우, 해당 예외가 발생하면 곧바로 종료된다.

### NullPointerException

이것은 객체 참조가 없는 상태

즉 null 값을 갖는 참조 변수로 객체 접근 연산자인 도트 를 사용했을때 발생한다.

### ArrayIndexOutOfBoundsException

배열에서 인덱스 범위를 초과하여 사용할 경우 실행예외가 발생한다.

예: 길이가 3인 int[] arr = new int[3] 배열을 선언을 했다면, 배열 항목을 지정하기위해 arr[0]~arr[2]까지 사용할수 있지만 arr[3]를 사용하면 인덱스범위 초과로 발생한다.

### NumberFormatException

숫자로 변환될 수 없는 문자가 포함되어있다면 java.lang.NumberFormatException을 발생시킨다.

### ClassCastException

타입 변환은 상위 클래스와 하위 클래스 간에 발생하고 구현 클래스와 인터페이스 간에도 발생한다. 이러한 관계가 아니라면 클래스는 다른 클래스로 타입 변환할 수 없다.

억지로 타입 변환을 시도할 경우 ClassCastException이 발생한다.

## 예외처리 코드

프로그램에서 예외가 발생했을 경우 프로그램의 갑작스러운 종료를 막고, 정상 실행을 유지할 수 있도록 처리하는 코드를 예외 처리 코드라고 한다.

예외 처리 코드는 try-catch-finally 블록을 이용한다. try-catch-finally 블록은 생성자 내부와 메소드 내부에서 작성되어 일반 예외와 실행 예외가 발생할 경우 예외처리를 할수 있도록 해준다.

```java
try {
    // 실행 코드
} catch (Exception e) {
    // 예외 처리 코드
}
```

### 동작 방식

- try 블록에는 예외 발생 가능 코드가 위치한다. try 블록의 코드가 예외 발생 없이 정상 실행되면 catch 블록의 코드는 실행되지않고 finally 블록의 코드를 실행한다.
- 만약 try 블록의 코드에서 예외가 발생하면 즉시 멈추고 catch 블록으로 이동하여 예외 코드를 실행한다 . 그리고 finally 코드를 실행한다.
- finaly 블록은 옵션으로 생략 가능하다.
- 예외 발생 여부와 상관없이 항상 실행할 내용이 있을 경우에만 finally 블록 작성해주면된다.
- try 블록과 catch 블록에서 return 문을 사용하더라도 finally 블록은 항상 실행된다.

### 다중 catch

try 블록 내부는 다양한 종류의 예외가 발생할 수 있다. 이 경우, 발생되는 예외별로 예외 처리 코드를 다르게 하려면 어떻게 하면 될까? 이것에 대한 해답은 다중 catch를 작성하는것이다.

catch 블록이 여러개라 할지라도 단 하나의 catch 블록만 실행된다. 그 이유는 try 블록에서 동시 다발적으로 예외가 발생하지 않고, 예외가 발생하면 즉시 실행을 멈추고 해당 catch 블록으로 이동하기 때문이다.

### catch 순서

다중 catch 블록을 작성할때 주의할 점은 **상위 예외 클래스가 하위 예외클래스**보다 아래쪽에 위치해야한다.

try 블록에서 에외가 발생하였을때, 예외를 처리해줄 catch 블록은 위에서부터 차레대로 검색된다. 만약 상위 예외 클래스의 catch 블록이 위에있다면 , 하위 예외 클래스의 catch 블록은 실행되지않는다. 왜냐하면 하위 예외는 상위 예외를 상속했기 때문에 상위 예외 타입도 되기 때문이다.

### 예외 떠넘기기

메소드 내부에서 에외가 발행할 수 있는 코드를 작성할때 try-catch 블록으로 예외를 처리하는 것이 기본이지만, 경우에 따라서는 메소드를 호출한 곳으로 예외를 떠넘길수도있다. 이때 사용하는 키워드가 throws이다.

throws 키워드는 메소드 선언부 끝에 작성되어 메소드에서 처리하지않은 예외를 호출한 곳으로 떠넘기는 역할을 한다. throws 키워드 뒤에는 떠넘길 예외 클래스를 쉼표로 구분해 나열하면된다.

```java
리턴타입 메소드명(매개변수,) throws 예외클래스1, 에외클래스2{
}
```

발생할 수 있는 예외의 종류별로 throws 뒤에 나열하는 것이 일반적이지만, 다음과 같이 throw Exception 만으로 모든 예외를 간단히 떠넘길 수도있다.

```java
리턴타입 메소드명(매개변수, ) throws Exception{
}
```

- throws 키워드가 붙어있는 메소드는 반드시 try 블록 내에서 호출되어야한다.
- 그리고 catch블록에서 떠넘겨 받은 예외를 처리해야한다

### 사용자 정의 예외와 예외 발생

프로그램 개발을 하다보면 자바 표준 API에서 제공하는 예외 클래스만으로는 다양한 종류의 예외를 표현할수없다

잔고 부족 예외와 같이 애플리케이션 서비스와 관련된 예외를 애플리케이션 예외 라고 한다. 애플리케이션 예외는 개발자가 직접 정의해서 만들어야하므로 사용자 정의 예외라고도한다.

### 사용자 정의 예외 클래스 선언

사용자의 정의 예외 클래스는 **컴파일러가 체크하는** 일반 예외로 선언할 수도 있고, **컴파일러가 체크하지않는** 실행 예외로 선언할 수도 있다. 일반 예외로 선언할 경우 Exception 을 상속하면되고, 실행 예외로 선언할 경우에는 RuntimeException을 상속하면된다.

```java
public class XXXException extends [ Exception | RuntimeException] {
	public XXXException() {}
	public XXXException(String message){super(message);}
```

사용자 정의 예외 클래스 이름은 Exception으로 끝나는게 좋다

사용자 정의 예외 클래스도 필드 , 생성, 메소드 선언들이 포함될수있지만 대부분 생성자 선언만 포함함

생성자는 두개를 선언하는것이 일반적

1. 매개변수가 없는 생성자
2. 예외 발생 원인을 전달하기 위해 String 타입의 매개 변수를 갖는 생성자이다.
   - String 타입의 매개변수를 갖는 생성자는 상위 클래스의 생성자를 호출하여 예외 메세지를 넘겨준다. 예외 메세지의 용도는 catch{} 블록의 예외처리 코드를 이용하기 위해서이다.
