## 객체 생성과 클래스 변수

클래스로부터 객체를 생성하는법은 new연산자를 사용하면된다.

new 연산자로 생성된 객체는 메모리 힙 영역에서 생성된다. 현실 세계에서 물건의 위치를 모르면 물건을 사용할 수 없듯이 객체지향 프로그램에서도 메모리 내에서 생성된 객체의 위치를 모르면 객체를 사용할 수 없다. 그래서 new 연산자는 힙 영역에 객체를 생성시킨후 객체의 주소를 리턴하도록 되어있다.

리턴한 객체의 주소를 저장하는 코드이다.

```java
클래스 변수;
변수 = new 클래스();
```

클래스 변수 선언과 객체 생성을 한 개의 실행문으로 작성할 수도 있다.

```java
클래스 변수 = new 클래스();
```

이렇게 new 연산자로 객체를 생성하고 리턴된 객체의 주소를 변수에 저장하면 변수가 객체를 참조하게 된다

예제

```java
public class Student{
}
```

```java
public class ClassName{
//필드 선언
int filedName; // 필드 : 객체의 데이터가 저장되는곳

//생성자 선언
ClassName() {} // 생성자: 객체 생성 시 초기화 역할 담당

//메소드 선언
int methodName() {} //메소드 : 객체의 동작으로 호출 시 실행하는 블록
}
```

### 필드

- 필드 는 객체의 데이터를 저장하는 역할을 한다. 선언 형태는 변수 선언과 비슷하지만 쓰임새에 따라다르다.

### 생성자

- 생성자는 new연산자로 객체를 생성할때 객체의 초기화를 담당한다. 선언 형태는 메소드와 비슷하지만 리턴 타입이없고 이름은 클래스 이름과 동일하다

### 메소드

- 메소드는 객체가 수행할 동작이다 다른프로그램 언어에서 함수라고 하기도한다 객체 내부의 함수는 메소드라고 부른다
- 메소드는 객체와 객체간의 상호 작용을 위해 호출된다.

# 필드 선언과 사용

필드는 **객체의 데이터**를 저장하는 역할을한다. 객체의 데이터에는 고유 데이터 현재 상태 데이터 부품데이터가 있다

```java
public class Car{
//고유 데이터를 저장하는 필드선언
String company;
Stirng model;
String color;
int maxSpeed;

//상태 데이터를 저장하는 필드선언
int speed;
int rpm;

//부품 데이터를 저장하는 필드선언
Body body;
Engine engine;
Tire tire;
}
```

## 필드사용

필드를 사용한다는 것은 필드값을 읽고 변경하는것을말함

클래스에서 필드는 객체의 데이터이므로 객체가 존재하지 않으면필드도 존재 하지 않는다.

객체 내부에서는 단순히 필드명으로 읽고 변경할 수 있지만 외부 객체에서는 참조변수와 도트 연산자를 이용해서 필드를 읽고 변경해야한다. 도트는 객체 접근 연산자로 객체가 가지고있는 필드나 메소드에 접근하고자 할때 참조변수 뒤에 붙인다.

## 생성자 선언과 호출

new연산자는 객체를 생성한후 연이어 생성자를 호출해서 객체를 초기화하는 역할을한다.

객체 초기화란 필드 초기화를 하거나 메소드를 호출해서 객체를 사용 하는것을 말한다.

### 메소드 오버로딩

클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것을 메소드 오버로딩 이라고 한다.

오버로딩의 사전적 의미는 많이 싣는것을 말하는데. 하나의 메소드 이름으로 여러 기능을 담는다 하여 붙여진 이름이라고 생각할수있지만

메소드 오버로딩의 조건은 매개변수의 타입,개수,순서중 하나가 달라야한다.

메소드 오버로딩이 필요한이유는 매개값을 다양하게 받아 처리할수록 하기위해서이다.

```java
int plus(int x,int y){
	int result = x + y;
	return result;
}
```

plus()메소드를 호출하기위해서는 두 개의 int 매개값이 필요하다.

하지만 int 타입이 아니라 double타입의 값을 덧셈하기위해서는 plus()메소드를 호출할 수 없다.

```java
double plus(double x, double y){
	double result = x+y;
	return result
}
```

오버로딩된 메소드를 호출할 경우 JVM은 매개값의 타입을 보고 메서드를 선택한다

예:

plus(10,20)을 하면 plus(int x, int y)가 실행되고

plus(10.5,20.3)을 하면 plus(double x, double y)가 실행된다.

```java
int x = 10;
double y = 20.3
plus(x,y);
```

이렇게 선언되도 오류가 일어날거같지만 놀랍게도 plus(double x, double y)메소드가 실행된다.

자바 가상 기계는 일차적으로 매개변수 타입을 보지만, 매개 변수의 타입이 일치하지 않을 경우 , 자동 타입 변환이 가능한지를 검사한다. 첫번째 매개변수인 int 타입은 double타입으로 변환이 가능하므로 최종적으로

plus(double x, double y) 메소드가 선택된다.

하지만 리턴 타입만 다르고 매개변수가 동일하다면 이것은 오버로딩이 아니다. 그러므로 컴파일 오류가일어난다.

### 인스턴스 멤버와 this

인스턴스 멤버란 객체(인스턴스) 를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다. 우리가 지금까지 작성한 모든 필드와 메소드는 인스턴스 멤버들이있다.

인스턴스 필드와 메소드는 객체에 소속된 멤버이기 때문에 객체 없이는 사용할 수 없다. Car클래스에 gas필드와 setSpeed() 메소드가 다음과 같이 선언되어있다고 가정 해보자

```java
public class Car{
	int gas;

	void setSpeed(int speed){
	}
}
```

gas 필드와 setSpeed() 메소드는 인스턴스 멤버이기 때문에 외부 클래스에서 사용하기 위해서는 우선 Car객체를 생성하고 참조 변수 myCar 또는 yourCar로 접근해야한다

```java
Car mycar = new Car();
myCar.gas = 10;
myCar.setSpeed(60);

Car yourCar = new Car();
yourCar.gas = 20;
yourCar.setSpeed(80);
```

인스턴스 필드 gas는 객체마다 따로 존재하고 , 인스턴스 메소드 setSpeed()는 객체마다 존재하지 않고 메소드 영역에 저장되고 공유된다.

객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는것과 마찬가지로 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할수있다. 우리가 자신을 “나” 라고 표현하듯이. 객체는 자신을 this라고한다.

따라서 this.model은 자신이 가지고있는 model 필드라는 뜻이다.

this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우. 인스턴스 멤버인 필드임을 명시하고자 할때 사용된다. 다음은 매개 변수 model 의 값을 필드 model에 저장한다.

```java
Car(String model){
	this.model = model;
}
void setModel(String model) {
	this.model = model;
}
```

### 정적 멤버와 static

정적(static)은 고정된 의미를 가지고있다. 정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지않고 사용할수있는 필드와 메소드를 말한다. 이들을 각각 정적 필드, 정적 메소드라고 부른다. 정적 멤버는 객체에 소속된 멤버가 아니라 클래스에 소속된 멤버이기 때문에 클래스 멤버라고도한다.

정적 메소드와 블록 선언시 객체가 없어도 실행된다는 특징 때문에 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할수 없다. 또한 객체 자신의 참조인 this 키워드도 사용이 불가능하다.

### Getter와 Setter 메소드

일반적으로 객체 지향 프로그래밍에서 객체의 데이터는 외부에서 직접적으로 접근하는것을 막는다.

이유: 객체의 데이터를 외부에서 마음대로 읽고 변경하면 객체의 무결성이 깨질수도있기 때문이다.

예: Car객체의 speed 필드값을 마음대로 음수로 바꿔버림

이러한 문제점을 해결하기위해 객체 지향 프로그래밍에서는 메소드를 통해서 데이터를 변경하는 방법을 선호함

데이터는 외부에서 접근할수없도록 막고 메소드는 공개해서 외부에서 메소드를 통해 데이터에 접근하도록 유도한다.

그 이유는 메소드는 매개값을 검증해서 유효한 값만 데이터에 저장할수있기때문에.

이러한 역할을하는 메소드는 Setter이다.

Getter메소드는 필드값을 가공한 후 외부로 전달하면 되게된다.

예를 들어 자동차의 속도를 마일에서 KM단위로 환산해서 외부로 리턴해주는 getSpeed()메소드는 이렇게 작성된다.

```java
double getSpeed(){
	double km = speed*1.6;
	return km;
}
```

클래스를 선언할때 가능하면 필드를 private로 선언해서 외부로부터 보호하고 필드에 대한 Setter 와 Getter메소드를 통해 필드값을 안전하게 변경/사용하는것이좋다.

### 어노테이션

어노테이션은 메타 데이터 라고도 볼수있다. 메타데이터란 애플리케이션이 처리해야 할 데이터가 아니라, 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할것인지를 알려주는 정보이다.

어노테이션은 3가지 용도로 사용된다.

- 컴파일러에게 코드문법 에러를 체크하도록 정보 제공
- 소프트웨어 개발 툴이 빌드나 배치시 코드를 자동으로 생성할 수있도록 정보제공
- 실행시 특정 기능을 실행하도록 정보 제공

컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공하는 대표적인 예 @Override 어노테이션 이다.

@Override는 메소드 선언시 사용하는데 메소드가 오버라이드된 것임을 컴파일에게 알려주어

컴파일러가 오버라이드를 검사하게해준다.
